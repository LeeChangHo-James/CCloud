[Property]
● Property
  ▶ private를 사용하여 정보의 은닉성을 사용할 때 Set(), Get()함수로 은닉이 가능하다.
     ▶ 변수가 추가 될 때 마다 Get(),Set()을 변수마다 지정해주어야 하고 코드에 도배가 되어 가독성이 떨어진다. (은닉성은 지키지만 효율이 떨어진다.)
        ▶ 이러한 문제점 때문에 은닉성과 편의성을 제공해주기 위해 C#은 프로퍼티를 제공한다.

● 메소드보다 프로퍼티
  ▶ 프로퍼티 사용법
     ex) class 클래스 이름
         {
             데이터형식 필드이름;
             접근한정자 데이터형식 프로퍼티 이름
             {
                 get
                 {
                     return 필드이름;
                 }

                 set
                 {
                     필드이름 = value;
                 }
             }
         }
     ▶ get{...}과 set{...}을 일컬어 접근자라고 한다.
        ▶ get 접근자는 필드로부터 값을 읽어오고 set 접근자는 필드에 값을 할당한다.
           ▶ set 접근자의 value 키워드는 선언한적 없지만 C# 컴파일러는 set 접근자의 암묵적 매개 변수로 간주한다.
        ▶ 읽기 전용으로 만들고 싶을 때는?
           ▶ 메소드를 통해 필드가 변경되지 않기를 원할 때는 set 메소드를 구현하지 않는다.
              ▶ 그럼 프로퍼티를 통해 필드가 변경되지 않을려면 어떻게 해야할까?
                 ▶ 프로퍼티도 set을 구현하지 않는다.
                    ex) class 클래스 이름
                    {
                        데이터형식 필드이름;
                        접근한정자 데이터형식 프로퍼티 이름
                        {
                            get
                            {
                                return 필드이름;
                            }
                        }
                    }
        ▶ 쓰기 전용으로 만든다면?
           ▶ 쓰기 전용으로 만든다면 프로그래들에게 공유할 때 쓰기 전용 프로퍼티의 용도와 동작 결과를 확인할 수 있는 방법을 알려주어야한다.
              ▶ 그렇지 않다면 그 프로퍼티는 코드를 관리하기 어렵게 만드는 하나의 원인이 된다.     

● 자동 구현 프로퍼티 
  ▶ 프로퍼티는 데이터의 오염에 대해선 메소드처럼 안전하고, 데이터를 다룰 때는 필드처럼 간결하다. 많은 경우에 중복된 코드를 작성하고 있다는 기분이 들게 한다.
     ▶ C# 3.0 
        ▶ 간결하게 만들어줌
           ex) public class NameCard
               {
                   public string Name
                   {
                       get; set;
                   }

                   public string PhoneNumber
                   {
                       get; set;
                   }
               } 
     ▶ C# 7.0
        ▶ 초기화 가능
           ex) public class NameCard
               {
                   public string Name{ get; set; } = "Unknown";
                   public string PhoneNumber{ get; set; } = "000-0000";
                } 

● 프로퍼티와 생성
  ▶ 객체를 생성할 때 각 필드를 초기화하는 방법(프로퍼티를 이용한 초기화)
     ex) 클래스이름 인스턴스 = new 클래스이름()
         {
             프로퍼티1 = 값,
             프로퍼티2 = 값,   // ;이 아니라 콤마, 사용
             프로퍼티3 = 값
         };

● 무명형식
  ▶ 무명 형식은 형식의 선언과 동시에 인스턴스를 할당한다.
     ▶ 무명 형식은 인스턴스를 만들고 다시는 사용하지 않을 때 요긴하다.
        (두 개 이상의 인스턴스를 만들려면 class나 struct를 이용해서 이름을 가진 형식을 별도로 만들면된다.)
        ex) var myInstance = new { Name = "이창호", Age = "17" };
            ▶ 괄호 {와} 사이에 임의의 프로퍼티 이름을 적고 값을 할당하면 그대로 새 형식의 프로퍼티가 된다.
            ▶ 선언한 무명 형식의 인스턴스는 여느 객체처럼 프로퍼티에 접근하여 사용이 가능하다.
  ▶ 무명 형식에서 주의할 점
     ▶ 무명 형식의 프로퍼티에 할당된 값은 변경 불가능하다는 사실
        ▶ 한번 무명 형식의 인슨턴스가 만들어지고 난 다음에는 읽기만 할 수 있다는 이야기
  ▶ LINQ와 함께 사용하면 아주 요긴하게 사용이 가능하다.

● 인터페이스의 프로퍼티  
  ▶ 인터페이스는 메소드뿐만 아니라 프로퍼티와 인덱서도 가질 수 있다.
     ▶ 프로퍼티나 인덱서를 가진 인터페이스를 상속하는 클래스가 "반드시" 해당 프로퍼티와 인덱서를 구현해야 하는 것은 물론이다.
        ▶ 인터페이스에 들어가는 프로퍼티는 구현을 갖지 않는다. 
     ▶ 인터페이스의 프로퍼티 선언이 클래스의 자동 구현 프로퍼티 선언과 그 모습이 동일하다는 사실
        ex) interface 인터페이스이름
            {
                public 형식 프로퍼티이름1
                {
                    get; set;
                }

                public 형식 프로퍼티이름2
                {
                    get; set;
                }
            }      

● 추상 클래스와 프로퍼티  
  ▶ 추상 클래스는 클래스처럼 구현된 프로퍼티를 가질 수도 있는 한편, 인터페이스처럼 구현되지 않은 프로퍼티도 가질 수 있다.
     ▶ 추상 클래스에서는 이것을 추상 프로퍼티(Abstract Property)라고 한다. 
     ▶ 추상 메소드가 그랬던 것 처럼, 추상 프로퍼티 역시 인터페이스의 프로퍼티와 다를 것이 없다.
        ▶ 파생 클래스가 해당 프로퍼티를 구현하도록 강제하는 것일 뿐
     ▶ 추상 프로퍼티 구현법
        ▶ C# 컴퍼일러가 자동 구현 프로퍼티로 간주하고 구현을 자동으로 채워 넣기 때문에
           ▶ abstract 한정자를 이용해서 선언한다.
              ex) abstract class 추상 클래스이름
                  { 
                       abstract 데이터형식 프로퍼티이름
                       {
                           get;
                           set;
                       }
                  }
                  ▶ 추상 클래스는 구현을 가진 프로퍼티와 구현이 없는 추상 프로퍼티 모두를 가질 수 있다.
                     ▶ 파생 클래스는 부모 추상 클래스의 모든 추상 메소드뿐 아니라 추상 프로퍼티를 재정의 해야 한다.     
                         