[Coroutine]
● Coroutine
  ▶ 동시 실행(협동) 루틴
     ▶ 호출 루틴과 피호출 루틴이 대등 관계를 유지하는 처리 절차
        ▶ 부차적 프로그램의 수행이 완전히 끝나기 전에 제어가 호출 루틴으로 돌아가는 것이 동시 실행 과정
           ▶ 제어가 부차적 프로그램으로 돌아 왔을 때는 중단된 부분부터 다시 수행이 계속 된다.
              (주종 관계를 갖지 않고 서로 호출하는 둘 이상의 모듈들)
           ▶ 서브루틴의 제어 전달 개념과 유사하다.
              ▶ 서브루틴과 다른점은 호출 시 관련된 모든 정보를 보존하는 능력을 갖는다는 것
                 ▶ 다음에 다시 시작할 때에는 이전에 실행했던 부분의 다음부터 실행 할 수 있는 논리를 갖는다.
   ▶ Coroutine의 경우 어느 쪽도 종속 관계가 아니라 대등한 관계로 서로를 호출한다.
      (프로그램에서 순서는 일반적으로 불려지는 쪽이 부르는 쪽에 속하고 있는것이 대부분이다.)
      ▶ ex1) 게임 프로그램에서 각 플레이어 루틴은 서로 Coroutine 된다.
      ▶ ex2) 복수 프로세스 간에서 한정된 형태의 통신을 행하는 프로그램을 순차 제어로 실현한 것이다.              
   ▶ C언어 등에서 일반적으로 사용하는 함수는 시작할 때 진입하는 지점이 하나 존재하고 함수가 모두 실행되거나,
      return 구문에 의해서 종료되는 지점을 설정 할 수 있다.
      ▶ 이러한 함수를 서브 루틴(subroutine)이라 부른다.
         ▶ 코루틴은 이를 더 일반화한 개념으로 진입하는 지점까지 여러 개를 가질 수 있는 함수를 의미한다.
            (서브 루틴도 코루틴의 한 종류)
   ▶ Coroutine은 프로그램 상에서 보면 멀티 쓰레드와 비슷한 개념
      ▶ 별도의 스택과 지역변수들을 가진 실행 중, 각자의 메모리 영역과 실행 명령 포인터를 가지고 있어,
         재개(Resume)와 양보(yield)가 가능한 구조로 되어 있다.
         ▶ 중지(yield)하면 실제 프로그램(함수)는 종료되지 않고 위치를 대기시킨 후 값이 만들어지는 시점부터
            다시 시작(resume) 할 수 있다는 말이다.

● yield 
  ▶ Coroutine은 Yield를 사용하여 중간에 제어권을 다른 함수에 넘겨주는 역할을 한다.
     ▶ yield return new WaitForSecond(3.0f); // 3초 대기 후에 리턴을 해준다.
        ▶ yield를 사용하여 일정시간 대기 할 수 있는 함수
  ▶ update 함수상에서는 yield 문의 직접적인 사용 금지

● IEnumerator
  ▶ 제네릭이 아닌 컬렉션을 단순하게 반복할 수 있도록 지원하는 인터페이스 // 우리말로 열거자
     ▶ 데이터의 목록을 하나씩 넘겨 줄 때 사용되는 인터페이스
        ▶ 코루틴을 호출한 함수와 서로 상호작용하면서 진행하도록 설계
           ▶ 코루틴은 자신을 호출한 함수에 데이터를 하나 넘겨주고 쉰다
           ▶ 받은 측에서는 데이터를 받고 나서 처리한 후에 코루틴에게 다음 데이터를 달라고 깨운다.
           ▶ 쉬고 있던 코루틴은 일어나서 다시 데이터를 전달하고 이를 계속 반복하는 구조로 동작한다.
        ▶ 호출한 함수에게 데이터를 전달 할때, return 구문을 사용하게 되면 데이터를 전달하고 함수는 종료

● StartCoroutine 함수
  ▶ IEnumerator 반환형을 받아 yield이 만날 때 함수를 일시 정지하고, 다른 스크립트나 함수에게 활동을 넘긴다.
     = 코루틴 함수를 구동하는 함수

● 엔진이 제공하는 데이터들과 이를 수행하는 명령들
  ▶ Yield return null : 다음 프레임까지 대기
     ▶ null - the coroutine executes the next time that it is eligible
  ▶ Yield return new WaitForSeconds(float) : 지정된 초(float) 만큼 대기
     ▶ WaitForSeconds - causes the coroutine not to execute for a given game time period
  ▶ Yield return new WaitForFiexedUpdate() : 다음 물리 프레임까지 대기
     ▶ WaitForFixedUpdate - causes this coroutine to execute at the next physics step, after all physics is calculated
  ▶ Yield return new WaitForEndOfFrame() : 모든 렌더링 작업이 끝날 때 까지 대기 
     ▶ WaitForEndOfFrame - the coroutine executes on the frame, after all of the rendering and GUI is complete
  ▶ Yield return StartCoroutine(string) : 다른 코루틴이 끝날 때 까지 대기
  ▶ Yield return new WWW(stirng) : 웹 통신 작업이 끝날 때까지 대기
     ▶ WWW - waits for a web request to complete (resumes as if WaitForSeconds or null)
  ▶ Yield return new AsyncOperation : 비동기 작업이 끝날 때 까지 대기 (씬로딩)
  // Another coroutine - in which case the new coroutine will run to completion before the yielder is resumed

  ● Coroutine의 장점
    ▶ 성능
       ▶ 모바일 기기에서 코루틴의 활용은 성능 향상에 큰 영향을 미친다.
          ▶ 코루틴은 유니티 엔진에서 WaitForSeconds(3.0f) 라는 데이터를 보내고 쉬기 시작
             ▶ 유니티 Update를 이용해 위와 같이 작동한다면 Update에서 수 없이 호출 해야하기 때문에 성능 다운발생
                ▶ 코루틴을 이용하면 이러한 현상을 크게 줄여 성능향상을 시킬 수 있다.
    ▶ 가독성
    ▶ 코루틴을 사용하면 읽기 좋은 코드가 만들어진다.

● 특징 및 활용
  ▶ 가장 많이 사용되는 건 WaitForSecond 명령
     ▶ 멀티 쓰레드 프로그래밍의 Thread.Sleep 함수 처럼 원하는 시간 만큼 잘수 있다.
     ▶ 더욱 좋은 점은 엔진과 동일한 싱글 쓰레드로 돌아가기 때문에, 멀티 쓰레드 프로그래밍의 어려운 부분인 자원 관리 및 컨텍스트 스위칭(Context Switching)과 같은 다양한 고려 사항의 필요가 없다.
  ▶ 두번째로 많이 사용하는 부분은 비동기 작업
     ▶ 웹에서의 데이터 수신, 씬 로딩과 같이 오래 걸리는 작업은 엔진에게 넘기고, 자신은 진행상황을 점검하면서 UI 처리만 수행하는 형태로 사용.
        ▶ 엔진이 웹에서 다운받은 데이터를 객체에 완료 상황보고와 함께 저장을 하고 스크립트를 깨우면 스크립트는 쉬고 있다 객체를 가지고 다음 작업을 진행한다.
  ▶ 코루틴을 사용하여 작업을 원하는 대로 순차적으로 수행 할 수 있다.
     ▶ A,B 길중 한가지를 선택했을 때 그방향으로 진행이 가능하도록 설정 가능
     ▶ 결과 값의 유효성을 강화하고 싶다면 enum를 보조적으로 사용하는 것도 좋은 방법

   = 이러한 특징을 잘 활용하면 AI를 위한 유한상태 기계(Finite State Machine)을 구현할 때에도 별도의 클래스를 만들지 않고 쉽게 코딩이 가능하다.

   ▶ Coroutine는 for 루프 내에서는 사용할 수 없지만, while 문이나 foreach 문에서는 사용이 가능하다.

    
      
       


  

