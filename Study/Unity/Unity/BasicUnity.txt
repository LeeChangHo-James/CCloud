[Unity 키용어]
● Object Click + F = 오브젝트 자세히
● Art + Right Mouse Click = 씬 자유이동
● V + Object Click = 기즈모 축을 오브젝트 Vertex 위치로 변경
● Center, Pivot 모드 - Shift + Ctrl + 기즈모를 잡고 오브젝트 표면으로 이동
  ＊ Center : 게임 오브젝트의 바닥이 물체의 표면에 스냅
  ＊ Pivot : 게임 오브젝트의 중심이 물체의 표면에 스냅
   // 바닥이 되는 게임 오브젝트는 콜라이더가 존재 해야한다.

[Unity 기본용어]
● Vertex = 꼭짓점
● Edge = 모서리
● Polygon = 다각형, 특히 유니티에서는 삼각형 형태

=> 인식에 있어 뷰포리아, AR Foundation의 꼭짓점 추출을 한다면? 인식률 상승이 가능할까?
   ＊ 오브젝트 Vertex 추출 가능 여부
   ＊ 오브젝트 + 오브젝트가 맞 닿은 꼭짓점 Vertex 추출 가능 여부   

[유니티 좌표계]
● 유니티 좌표계는 왼손 좌표계를 사용한다.
  ▶ 왼손 좌표계는 게임 오브젝트의 등(뒷면)이 보이는 좌표계
  ▶ 게임 오브젝트가 전진하면 Z축의 값이 커지면서 화면 안쪽으로 전진하는 좌표계
     ▶ X축 = 오른쪽, 왼쪽
     ▶ Z축의 양수의 값이 앞쪽을 가리킨다.

[글로벌 좌표계]
▶ 글로벌 좌표는 게임 화면을 기준으로 하는 절대 좌표
▶ 게임 오브젝트의 기즈모는 게임 오브젝트가 바라보는 방향과는 상관없이 씬 기즈모와 같은 방향으로 표시

[로컬 좌표계]
▶ 게임 오브젝트를 기준으로 한 좌표
▶ 게임 오브젝트가 바라보는 방향이 Z축
▶ 유니티는 게임 오브젝트의 이동 및 회전에 대해 로컬 좌표를 사용

[셰이더]
● 셰이더란 빛의 정보를 이용해 기본적인 명암을 주는 것 외에 빛의 투과, 빛의 반사등을 이용해 다양하게 물체를 표현하는 방법

[콤포넌트(Component)]
● Mesh Filter
  ▶ 3D 모델링의 형태와 관련한 데이터를 가지고 있는 컴포넌트 (화면에 보여지기 위해서는 필수)
● Mesh Renderer 
  ▶ 실제로 오브젝트를 화면에 렌더링 하기 위한 옵션을 가지고 있는 컴포넌트 (화면에 보여지려면 필수)
● Collider
  ▶ 충돌을 감지하고 처리하기 위한 옵션을 가지고 있는 컴포넌트
● Rigidbody
  ▶ 질량, 마찰력, 회전 시 마찰력, 중력 사용 여부 등을 지정함으로써 게임 오브젝트에 물리 기능을 부여

[텍스쳐 설정]
● Material
  ▶ 기본 바탕을 흰색으로 지정 후 설정 흰색(255,255,255) / 검정(0,0,0)
  ▶ 표면에 맞춰 타일링(Tiling)값 조절
● Physics Material(물리 재질) //Create -> Physic Material
  ▶ 물리 재질의 경우 콜라이더 컴포넌트에 재질을 추가해 표현
     ▶ Dynamic Friction : 이미 이동 중일 때 사용되는 마찰. 일반적으로 0에서 1사이의 값을 사용
        0이면 얼음 같은 느낌, 1일 때는 큼 힘 또는 중력을 오브젝트에 가하지 않은 한 매우 빠르게 정지
     ▶ Static Friction : 오브젝트가 평면에 정지해 있을 때 사용되는 마찰. 일반적으로 0에서 1사이의 값을 사용
        0이면 얼음 같은 느낌이 되고, 1일 때는 오브젝트가 매우 강하게 움직임
     ▶ Bounciness 표면이 반동하는 방법을 나타낸다. 값을 0으로 설정하면 반동하지 않는다
        값을 1로 설정하면 에너지의 손실 없이 반동한다. // Bounciness 값의 크기가 더 크게 되면 더 높이 튀어 오른다.

=> 반짝이거나 투명한 표현을 할려면 셰이더를 이용해야한다.

[조명]
● Directional light는 일종의 태양 빛   
  ▶ 방향성만 있는 조명으로 게임 오브젝트의 위치에 따라 그림자 방향이 바뀌지 않는다.(태양과 인간의 거리는 멀어 위치와 상관없이 그림자 방향이 같음)        
● Point Light는 전구의 빛처럼 빛이 사방으로 고르게 퍼지는 조명      
  ▶ 거리에 따라 빛의 세기가 달라진다. 제한된 거리까지만 조명이 적용된다.

[유니티의 단위]
▶ 유니티는 밀리미터(mm)나, 인치(inch) 등의 실제 단위를 사용하지 않고, 3DS 맥스나 마야처럼 가상의 단위(Unit)를 사용한다.
   ▶ 3DS 맥스 시스템의 기본 단위 1은 인치(inch)
   ▶ 마야 시스템의 기본 단위 1은 센티미터(cm)
   ▶ 유니티 시스템의 기본 단위 1은 미터(m)

=> 오브젝트 1Unit = 1m 라고 생각하고 오브젝트 작업

[델타타임]
▶ 기기 성능에 따른 프레임 문제를 보정하기 위한 값
   ▶ 델타 타임은 Update 메서드의 현재 호출 시각과 이전 호출 시각의 차이 값을 반환
   ▶ 델타 타임의 값은 프로그래머가 보기에 적당한 값으로 설정 (보정할려는 값)

[이동,회전,]
● 이동 Transform
● 회전 Rotation
  ▶ Rotation은 Quaternion 값으로 대입해 주어야 한다.
  ▶ 쿼터니언 회전은 오일러 회전의 짐벌락이 발생하지 않지만 복잡한 숫자를 기반으로 하므로 직관적으로 이해하기 어렵다.
     ▶ 개별적으로 쿼터니언 구성 요서(x, y, z, w)에 접근하거나 수정하지 못한다.

+ [짐벌락]
  ＊ 짐벌락은 오일러 회전을 할 때 발생한다.
  ＊ 컴퓨터의 연산에서 오일러 회전은 x, y, z나 y, z, x등 순서대로 할 수 밖에 없으므로 나중에 이뤄지는 회전은 먼저 이뤄진 회전에 종속된다.
     = 짐벌의 두번째 고리가 도는 것 때문에 첫번째 고리가 겹쳐지면, 첫번째 고리와 세번째 고리의 회전이 겹쳐져 버리기 때문에 한 축에 대한 자유도를 상실하게 된다.
       = 두번째 고리를 움직일 때에 조심스러울 수 밖에 없다 이것을 짐벌락 현상이라 한다. ∴ 짐벌에 대한 이해가 필요하다.

[Identity]
  ▶ 게임에서 회전을 많이 한 다음에 초기화를 통해 월드의 방향과 회전을 일치시킨다거나 / A의 회전과 B의 회전을 일치시키기 위한 방법이 필요
     = Quaternion.identity를 이용한 정렬이 필요

[Update]
● Update
  ▶ 분당 60프레임 1초당 1프레임 제공
● FixedUpdate  
  ▶ 고정된 시간마다 호출되게 설계
  ▶ FixedUpdate에서 이동 계산을 적용할 때 델타 타임(Time.deltaTime) 값을 곱할 필요는 없다. 이는 프레임 속도와는 독립적으로 FixedUpdate()가 신뢰할 수 있는 타이머에서 호출되기 때문
  ▶ Edit → Project Settings → Time에서 설정가능

=> 화면을 그리는(렌더링) 작업은 Update에서 처리하고 물리 엔진 작업은 FixedUpdate에서 별개로 처리하고
   ∴ 기기의 성능차에 따라 프레임 속도가 낮더라도 실제로 물리적 계산은 일어나야 하기 때문

[GetComponent<가져오고 싶은 컴포넌트 이름>]
▶ 게임 오브젝트의 컴포넌트를 스크리브에서 코드로 가져오기 위한 메서드
   ▶ 사용법 ex) GetComponent<Rigidbody>().AddForce();

[Velocity]
▶ AddForce 메서드는 총탄이나 포탄, 공 등을 움직일 때 편하지만, 중간에 멈추지 못하는데, velocity를 설정하면 움직임이 멈춘다
   ∴ GetComponent<Rigidbody>().Velocity = new Vector3(0.0f, 0.0f, 0.0f);
      ▶ 유니티 메뉴얼에서는 velocity 값을 직접 고치지 말 것을 권유 
         = velocity 값을 직접 고치면 현실적이지 않은 결과가 나올 수도 있다고 주의

+ AddForce
  ▶ 게임 오브젝트의 뒤에서 밀어 버린 것처럼 외부에서 게임 오브젝트로 힘을 주는 것
  ▶ velocity는 게임 오브젝트의 현재의 순간 속도가 얼마인지 지정  

[질량]
▶ 질량(Mass)은 물질이 가지고 있는 고유한 물리량을 일컫는 말
▶ SI 단위는 킬로크램(kg)으로 일상생활에서 무게를 통해 쉽게 느낄 수 있는 매우 기초적인 물리량
▶ 공기 저항을 무시 했을 때, 질량과 관계없이 모든 물치는 같은 가속도(=중력가속도)로 낙하한다.
   ex) 공기가 없는 달에서 무거운 트럭과 가벼운 깃털은 같은 속도로 낙하한다.

[오브젝트 찾기]
▶ 하이라이커 창에서 오브젝트 찾는법
   = GameObject.Find("찾는 오브젝트 이름")

=> 찾은 오브젝트로 활용할 수 있는것은 다양하다.

[공전 자전 표현]
● public void RotateAround(Vector3 point, Vector3 axis, float angle);
  ▶ 첫 번째 파라미터는 중심 위치, 두 번째 파라미터는 회전의 중심이 될 축, 세 번째 파라미터는 회전 속도