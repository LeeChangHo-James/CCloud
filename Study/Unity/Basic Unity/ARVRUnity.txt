[유니티 VR환경 셋팅]
● XR Settings
  ▶ Project Settings의 XR Settings의 Virtual Reality Supported속성 체크
  ▶ Virtual Reality SDKs → + → Cardboard 선택 = Google Cardboard VR SDK가 추가

● Other Settings  
  ▶ Identification 영역의 Package Name을 설정 // 역도메인 = com.[회사명].[프로젝트명]
  ▶ 안드로이드 폰의 최소 사양을 설정하는 Minimum API Level 속성을 "Android 4.4 'kitkat'(API level 19)"로 선택 
     // Minimum API Level 속성은 "Android 9.0 'Pie'(API level 28설정) → Target API Level = "Automatic (highest installed)설정
     ▶ 구글 카드보드 = Android 4.4 'kitkat' (API level 19) 이상
     ▶ 데이드림 = Android 7.0 'Nougat' (API level 24) 이상  

[라이트 맵 베이킹]
▶ 3D 콘텐츠는 실시간 조명(Realtime Light)을 많이 사용할 수 없다.
   ＊ 실시간 조명은 런타임 시 조명 연산처리에 많은 부하를 주기 때문에 성능 저하의 원인이 된다.
   ＊ 모바일 기반의 콘텐츠는 거의 실시간 조명을 사용할 수 없다고 생각하는 것이 현실적이다.
   => 직접 광원, 간접 광원 및 그림자와 같은 조명 효과를 미리 텍스처로 생성한 후 런타임 시 미리 베이크된 텍스처를 오버레이(Overlay)해 흡사 실시간 조명을 배치한 것과 같은 효과를 주기 위해서 라이트 맵(Lightmap)을 사용한다.
   // 라이트 맵을 생성하는 절차를 "라이트 맵을 굽는다" 또는 "라이트 맵을 베이킹한다"라는 용어를 사용한다.
   // 라이트 맵을 베이킹하려면 먼저 유니티 엔진에 탑재된 라이트 맵을 생성하는 미들웨어 엔진인 Progressive Lightmapper에 라이트 매핑의 대상이 어떤 것인지 알려준다.
   ▶ 하이러키뷰 → 인스펙터 뷰(오른쪽 위) → Static 옵션에 체크 → Yes, change children 버튼 클릭(하위의 모든 게임오브젝트도 Static 옵션이 체크되도록 설정된다. 싫으면 NO)
      ＊ Static 옵션에 체크하면 해당 게임오브젝트는 이동할 수 없도록 고정된 객체라는 의미
      ＊ 또 다른 의미는 라이트매핑(Lightmapping), 오클루전 컬링(Occlusion Culling), 내비게이션(Navigation)과 같은 기능을 사용할 때 그 대상이 되는지 여부를 유니티 엔진에 알려주는 역할을 한다.
      ＊ Static 옵션에 체크한 이유는 자신을 포함해 그 하위에 있는 모든 객체(3D 모델)가 라이트매핑의 대상임을 표시한 것

[기능키]
● Add Component
  ▶ Ctrl + Shift + A

[Character Controller]
▶ Capsule Collider 컴포넌트와 물리 엔진의 효과를 같이 갖는 컴포넌트 
▶ Character Controller → Center → Y 값 = 1
   ▶ Character Controller의 바닥이 Player의 피봇 좌표와 정확히 일치하게 된다.
▶ Character Controller 컴포넌트는 SimpleMove라는 함수를 제공
   ▶ SimpleMove 함수의 인자로 방향과 속도를 지정하면 지정한 방향으로 초당 해당 속도로 이동하므로 별도의 Time.deltaTime 값을 곱하지 않아도 된다.
   // CharacterController.SimpleMove( 방향벡터 * 속도 ); 

[구글 카드보드의 에뮬레이션]
▶ Google VR SDK는 빌드하지 않고도 유니티 에디터에서 헤드 트레킹을 시뮬레이션할 수 있는 GvrEditorEmulator라는 프리팹을 제공한다.
   ▶ GoogleVR → Prefabs → GvrEditorEmulator를 하이러키 뷰로 드래그 앤 드롭
      // 유니터 에디터에서만 동작하는 스크립트, Transform의 Position 값은 아무런 의미가 없다. ∴ 아무 위치에 두어도 무방하다. 

[웨이포인트]
▶ 정해진 경로를 따라 자동으로 이동하거나 바라보는 시선을 따라 이동하기 위해 사용
▶ 이미 결정된 이동 경로 중 어느 한 지점을 웨이포인트(Way Point)라 지칭한다.
   ▶ 웨이포인트에 포인트가 되는 지점은 Sphere Collider가 필요 
      ▶ Is Trigger 옵션을 체크하면 물리적인 반발력이 발생하지 않는다.
         ▶ 오브젝트가 Point지점 위를 지나가도 관통하는 성격을 띠며 일종의 센서와 같은   역할을 한다. Is Trigger 옵션에 체크하지 않으면 주인공이 Sphere Collider를 타고 넘어간다.
   ▶ 충돌여부를 판정하기 위해서는 웨이포인트에 태그 설정이 필요하다
      ▶ 오브젝트 하위에 있는 게임오브젝트를 검색하는 방법
         ▶ 부모 오브젝트 찾기 GameOjbect 부모오브젝트변수명 = GameObject.Find("부모오브젝트");
            ▶ 전체 자식들의 값 = 부모오브젝트변수명.GetComponentsInChildren<Transform>(); 
            // GetComponentsInChildren 함수는 페어런트 컴포넌트와 차일드에 있는 모든 컴포넌트를 추출한다는 점을 명심     

+ [물리 엔진의 충돌 감지 연산 처리] (빠름 → 느림)
▶ Sphere Collider → Capsule Collider → Box Collider → Mesh Collide

[태그(tag)로 찾기, 비교하기]
<<찾기>>
● GameObject 변수명 = GameObject.Find("오브젝트 네임"); // 오브젝트 이름 찾기
● GameObject 변수명 = GameObject.FindGameObjectWithTag("태그 네임"); //태그로 찾기, 단일 반환
● GameObject[] 변수명 = GameObject.FindGameObjectWithTag("태크 네임"); // 태그로 찾기, 복수 반환

<<비교하기>>
● if(오브젝트변수명.tag == "태그네임") // string 비교 but string비교는 불필요한 리소스를 잡아 먹어 비효율적
● if(오브젝트변수명.CompareTag("태그네임")) // 유니티에서 만들어 놓은 비교 함수

[레이어 찾기 및 설정]
▶ VR상에서 레이어 찾기
   ▶ hit.collider.gameObject.layer == 숫자?  
▶ 레이어의 경우 하단의 모든 아이들에게 레이어를 줄 필요는 없다.
   ▶ 레이어로 지정해야하는 객체만 레이어로 지정되도록 한다. 

[Start 컴포넌트에서 컴포넌트 추출해 할당]
▶ 컴포넌트 속성을 통해 컴포넌트에 접근하는 것보다 Start 함수에서 컴포넌트를 추출해 할당하는것이 속도 면에서 유리

[Quaterion.LookRotation]
▶3차원 공간에서 벡터가 이루고 있는 각도를 계산하기 위해사용

[Quaterion.Splrp(a,b,t)]
▶ 보간(Interpolate) 함수로 시간의 계수인 t=0.0일 때는 a 각도를, t = 0.5일 때는 a와 b의 중간 각도인 (a+b/2)를 t=1.0일 때는 b 각도를 반환한다.

[카메라 시야 벡터]
▶ 카메라 시야가 방향적으로 움직이게 하기 위해서는 Y값을 0으로 준다
   ▶ Y값을 주게 되면 시야가 위쪽을 응시하면 공중으로 올라가는 방향아 되기 때문
▶ 항상 X,Z축 방향으로의 벡터를 계산해야 한다. Y값을 0으로 설정하면 항상 X,Z 좌표계에서의 벡터로만 계산된다.    

[레티클]
▶ 특정 객체나 메뉴를 시선으로 응시하려면 마우스 커서와 같은 조줌점이 필요 이러한 조준점을 레티클(Reticle)
▶ 레티클은 바라보는 시선의 중앙에 응시점이 생기며 특정 객체를 응시하면 크기가 변하거나 색상이 변해 응시하고 있는다는 것을 사용자에게 알려준다.

[Canvas]
▶ VR환경에서 UI 디자인 작업을 할 때는 일반적인 UI작업처럼 Canvas의 Render Mode 속성을 Screen Space로 설정해서는 안된다.
   ∴ Canvas의 Render Mode를 반드시 World Space로 설정하고 카메라와 항상 90º 직교처리  돼야한다.
      ▶ World Space 변경시 Rect Transform 컴포넌트가 활성화된다. 
         ▶ Rect Transform 컴포넌트는 2D 및 UI환경에 최적화된 일종의 Transform 컴포넌트로 피봇(Pivot), 마진(Margin)값을 편하게 설정할 수 있다. 

[ray]
● 광선을 생성(광선의 시작점, 방향)
  ▶ Ray(오브젝트.position, 오브젝트.방향);
● DrawRay
  ▶ Debug.DrawRay(광선의 시작점, 길이, 색상);
● Raycast
  ▶ Physics.Raycast 함수는 광선을 투사해 조건에 맞는 객체가 닿으면 true 값을 반환하며 광선에 닿은 게임 오브젝트의 정보는 RaycastHIt 타입의 구조체에 저장된다.
  ▶ Raycast 메서드는 인자에 따라 총 16가지의 사용법이 있다
  ▶ Physics.Raycast(광선, out 반환받을 변수, 도달 거리, 검출할 레이어)

[Animator]
▶ 애니메이터 컨트롤러에 정의한 파라미터 값을 스크립트에서 적용할 경우 아래 문법사용
   ● Animator.SetFloot("파라미터명", 값);
   ● Animator.SetBool("파라미터 명", [true,false]);
   ● Animator.SetInt("파라미터 명", 값);
   ● Animator.SetTrigger("파라미터 명");
     ▶ 이 방식들은 호출할 때마다 내부의 해시테이블을 검색하는 과정을 거치기에 속도 면에서 불리하다.
     ▶ 호출할려는 파라미터의 해시값을 미리 추출한 후 그 값을 전달하는 방식이 훨씬빠르다.
     ▶ ex) hashIsLook = Animator.StringToHash("IsLook");

▶ Speed 속성은 애니메이션 클립의 속도를 조절하는 역할을 하며 -1로 지정하면 애니메이션 클립을 반대로 리버스(Reverse)시킨다는 의미
   ● Has Exit Time 
     ▶ Has Exit Time 속성에 체크하면 해당 Transition의 Conditions 조건을 만족하더라도 바로 전이가 일어나지 않고 이전 스테이트의 애니메이션 클립을 끝까지 수행하고 넘어간다. 
   ● Transition Duration(s)
     ▶ 다음 스테이트로 전이할 때 걸리는 시간(초)을 의미

[포인터 이벤트 정보]
▶ 현재 시점의 포인터 이벤트 정보를 추출하는 방법
   ▶ PointerEventData 변수 = new PointerEventData(EventSystem.current);
● ExecuteEvents.Execute
   ▶ 특정 게임오브젝트에 이벤트를 전달하는 역할을 한다. 
   ▶ ExecuteEvents.Execute(게임오브젝트, 이벤트 데이터, 이벤트 종류);

[공전, 자전]
▶ 공전의 기준을 자신으로 지정했기 때문에 자전하는 효과를 볼 수 있다.
▶ 지구가 이동하는 궤적을 표현 = Trail Renderer 컴포넌트 사용

